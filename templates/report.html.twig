{% extends "base.html.twig" %}

{% block title %}Rapporter{% endblock %}

{% block body %}
        
       <div class="twocol" id="reportcontent"> 
    <main class="main">
        <article>
          <h1>Redovisning</h1>
        
        
        
          <h2 id="kmom01">kmom01</h2>

          <p>Objektorientering är föga förvånande en viktig del av programmering, så man lär i princip stöta på det ganska ofta.
          Jag själv har gått kurser kring objektorienterad programmering i både python, c#, och c++. 
          Mycket av PHP:S modell kring objekt och klasser är likt andra programmeringsspråk, alltså att man behöver definiera en klass,
          göra konstruktor, och eventuella metoder. Om man till exempel vill göra en subklass som ärver från en annan klass använder man
          extends. Själva basen och strukturen ser ut mycket som den gör beroende på faktumet att symfony som ramverk används. 
          Det är skönt att ha en "annan" struktur att luta sig tillbaka emot för att göra det enklare att kod körs på en server, och dessutom blir
          CSS-och routing-hanteringen betydligt mycket enklare eftersom symfony tar hand om det själv.
          PHP The Right Way verkar generellt vara en bra resurs och lathund att kolla på om man är osäker på det bästa sättet
          att skriva en speciell bit kod som har ett specifikt syfte, samt även en bra style guide.
          Det jag gärna vill kolla lite närmare på från den artikeln är definitivt säkrehetsdelen, då webbprogrammering utan ett säkerhetstänk
          är riktigt bristfälligt. 
          Mitt TIL för den här uppgiften är: Gör alltid installationer helt korrekt, och fel som kräver ominstallationer tar ofta tid att lösa,
          speciellt om de inte är kopplad till egentliga fel i din egna kod. </p>
        
          <h2 id="kmom02">kmom02</h2>

          <p>Arv fungerar i PHP precis som det gör i andra programmeringsspråk, det vill säga att klasser kan ha subklasser som ärver från en basklass. 
          Oftast handlar det om att subklasser ärver funktioner som en basklass har, 
          men kanske har en egen konstruktor. Komposition är lite annorlunda men har en liknande princip. Om arv handlar om att en subklass är en klass, så handlar komposition om att
          en klass kan inehålla andra klasser. Till exempel kan det vara en klass som är en tågdepå där en klass i form av tåg kan finnas. 
          Om en basklass som har kompositon med en annan klass tas bort så försvinner också klasserna som basklassen innehåller.
          En interface är en slags mall som beskriver vilka funktioner en klass ska ha, men i själva interfacet så specifieras det inte vad klasserna ska göra. 
          Välidgt lik abstrakta funktioner i till exempel Python, med andra ord.
          En trait, å andra sidan, är en form av arv som fungerar om en subklass kan behöva ärva metoder från flera stycken basklasser. I det här fallet fungerar inte ett vanligt arv, 
          eftersom att i PHP kan bara en subklass bara ärva från en enda basklass. På det här sättet kan ärvandet av metoder användas i flera stycken klasser.
          
          Uppgiften löste jag genom att använda grundtanken att det finns 52 stycken kort i en kortlek. Alltså satte jag för varje kort i en kortlek en UTF-8 representation av ett kort, som visas
          som ett grafiskt kort i webbläsaren. Dessa 52 kort är de korten som finns i kortleken, alltså deckOfCards.
          Dessa kort kan sedan visas eller tas bort i deckOfCards-klassen, som också i sig kallar på en hand-klass när man drar ett eller flera kort från leken. Jag tyckte den 52-baserade lösningen med grafiska tecken-representationer
          av kort var bra, men i kommande uppgifter kanske det kommer att visa sig hur bra den lösningen egentligen är, då varje kort endast är en grafisk representation och har egentligen inget eget värde, förutom vilket
          av de 52 korten det är.  Däremot så skulle man alltid kunna lägga till värde som ett värde i arrayen där korten finns, för att på så sätt ha kort som nycklar och själva värdet på korten som värde.

          Det har fungerat relativt bra med symfony, men ibland verkar det som att ramverket inte hittar klasserna även om de finns där på grund av diverse anledningar som kan göra det lite frustrerande, då det egentligen
          aldrig är något fel.

          Mitt TIL för det här kursmomentet är: Man kan egentligen börja med att göra APIn i en sådan här uppgift, men i det här fallet tyckte nästan jag det var bättre att göra den sist. 
          </p>

          <h2 id="kmom03">kmom03</h2>

          <p>Både flödesdiagram och pseudokod är bra verktyg för att få lite struktur på sina tankar innan man sätter igång. 
          De har nästan lite liknande funktion som en tankekarta skulle ha i andra sammanhang, och gör att man kan fokusera mer på att skriva själva koden utan att fundera ut hur själva programmet ska fungera.
          Om man dessutom har gjort pseudokod hjälper detta också en stor del på vägen, för även om man kanske inte tillämpar den exakt som man skrev den så gör den att man kan få ett bra hum om hur man ska implementera den funktionen 
          som man skrev pseudokoden för. Själva uppgiften löste jag genom att utöka några av de klasserna som redan fanns, men gjorde också några nya till som behövdes för spelet.
          Här hade man kunnat gå till väga på lite olika sätt, men jag bestämde att dela upp spelaren och banken i två separata klasser där banken ärvde från spelaren, och hade sedan en game-klass som hanterade 
          logiken för vinnarberäkning och stoppa eller dra nya kort. Det hade varit möjligt att ha allt i en enda game-klass, men för läsbarhetens och enkelhetens skull valde jag att ha allting uppdelat.
          Det blev också enklare för mig att hålla reda på min egna kod på sättet jag valde, så jag är nöjd med min implementation även om jag nog hade kunnat flytta ännu mer av logiken till klasser, då jag var tvungen att ha lite 
          kod i controllern och hanterat all den logiken i game-klassen också. En annan sak som jag valde att göra som kanske är lite mer av en tolkningsfråga är att alla spelare börjar med två kort och poängen räknas även där,
          så att banken eller spelaren kan vinna eller förlora redan på det två första korten. 
          Sammantaget är jag däremot nöjd med hur jag löste implementationen.
          Även om det var lite strul med att sätta igång ramverket från början så underlättar det väldigt mycket med både felsökning och
          generell modularitet när man bestämmer sig för att lägga till nya funktioner. Det känns som att ett ramverk är rätt väg att gå om man 
          gör en applikation som ska ha flera olika funktioner på samma gång och vill ha ett enkelt och standardiserat sätt att hantera allt med objektorienterad PHP.
          Mitt TIL för det här momentet är: Ramverkets inbyggda felsöknings och debug-funktioner är väldigt kraftfulla och man kan få mycket info, använd dem.
          </p>

          <h2 id="kmom04">kmom04</h2>

          <p>Här kommer redovisningstexten för detta kursmoment.</p>

          <h2 id="kmom05">kmom05</h2>

          <p>Här kommer redovisningstexten för detta kursmoment.</p>

          <h2 id="kmom06">kmom06</h2>

          <p>Här kommer redovisningstexten för detta kursmoment.</p>

          <h2 id="kmom10">kmom10</h2>

          <p>Här kommer redovisningstexten för detta kursmoment.</p>

         


        </article>

    </main>

    <aside class="conttable">
      <h1>Innehåll</h1>
        <ul>
          <li class="rep"><a href="#kmom01">Kmom01</a></li>
          <li class="rep"><a href="#kmom02">Kmom02</a></li>
          <li class="rep"><a href="#kmom03">Kmom03</a></li>
          <li class="rep"><a href="#kmom04">Kmom04</a></li>
          <li class="rep"><a href="#kmom05">Kmom05</a></li>
          <li class="rep"><a href="#kmom06">Kmom06</a></li>
          <li class="rep"><a href="#kmom10">Kmom10</a></li>
        </ul>
    </aside>
  </div>

{% endblock %}